# -*- coding: utf-8 -*-
"""Traccia_progetto.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TxVlW-dnftvbewXgSJE1JZ9JfAd_5j7s

# Informazioni consegna
* Aggiungere i componenti del proprio gruppo in questo [form](https://forms.office.com/r/1WKBx4YgSH). 
* **I gruppi possono essere composti da massimo 3 persone. Nel caso si intenda fare il progetto da soli bisogna comunque aggiungere il proprio nome nel form.**
* Per la consegna è necessario caricare su Virtuale la relazione, il notebook Colab e le immagini generate.
* La consegna deve essere effettuata da un qualsiasi membro del gruppo e verrà automaticamente attribuita ai restanti componenti.
* Per i dettagli sulle tempistiche e le scadenze si faccia riferimento a Virtuale.

# Deblur Immagini
Il problema di deblur consiste nella ricostruzione di un immagine a partire da un dato acquisito mediante il seguente modello:

\begin{align*}
    b = A x + \eta
\end{align*}

dove $b$ rappresenta l'immagine corrotta, $x$ l'immagine originale che vogliamo ricostruire, $A$ l'operatore che applica il blur Gaussiano ed $\eta$ il rumore additivo con distribuzione Gaussiana di  media $\mathbb{0}$ e deviazione standard $\sigma$.

## Funzioni di blur
Le seguenti funzioni servono per applicare il blur di tipo gaussiano ad un'immagine.
"""

import numpy as np
import matplotlib.pyplot as plt
from skimage import data, metrics
from scipy import signal
from numpy import fft

# Create a Gaussian kernel of size kernlen and standard deviation sigma
def gaussian_kernel(kernlen, sigma):
    x = np.linspace(- (kernlen // 2), kernlen // 2, kernlen)    
    # Unidimensional Gaussian kernel
    kern1d = np.exp(- 0.5 * (x**2 / sigma))
    # Bidimensional Gaussian kernel
    kern2d = np.outer(kern1d, kern1d)
    # Normalization
    return kern2d / kern2d.sum()

# Compute the FFT of the kernel 'K' of size 'd' padding with the zeros necessary
# to match the size of 'shape'
def psf_fft(K, d, shape):
    # Zero padding
    K_p = np.zeros(shape)
    K_p[:d, :d] = K

    # Shift
    p = d // 2
    K_pr = np.roll(np.roll(K_p, -p, 0), -p, 1)

    # Compute FFT
    K_otf = fft.fft2(K_pr)
    return K_otf

# Multiplication by A
def A(x, K):
  x = fft.fft2(x)
  return np.real(fft.ifft2(K * x))

# Multiplication by A transpose
def AT(x, K):
  x = fft.fft2(x)
  return np.real(fft.ifft2(np.conj(K) * x))

"""## Generazione dataset
Generare un set di 8 immagini 512$\times$512 in formato ${\tt png}$ in scala dei grigi che contengano tra i 2 ed i 6 oggetti geometrici, di colore uniforme, su sfondo nero. 


![Immagine2.png](data:image/png;base64,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)

## 1) Generazione immagini corrotte
Degradare le immagini applicando, mediante le funzioni riportate nella cella precedente,  l'operatore di blur con parametri

+ $\sigma=0.5$ dimensione $5\times 5$
+ $\sigma=1$ dimensione $7\times 7$
+ $\sigma=1.3$ dimensione $9\times 9$

ed aggiungendo rumore gaussiano con deviazione standard $(0,0.05]$
"""



"""## 2) Soluzione naive

Una possibile ricostruzione dell'immagine originale $x$ partendo dall'immagine corrotta $b$ è la soluzione naive data dal minimo del seguente problema di ottimizzazione:
\begin{align}
  x^* = \arg\min_x \frac{1}{2} ||Ax - b||_2^2
\end{align}

La funzione $f$ da minimizzare è data dalla formula
  $f(x) = \frac{1}{2} ||Ax - b||_2^2 $, il cui gradiente $\nabla f$ è dato da
$\nabla f(x) = A^TAx - A^Tb  $.

Utilizzando il metodo del gradiente coniugato implementato dalla funzione `minimize` calcolare la soluzione naive. 
"""



"""## 3) Regolarizzazione
Per ridurre gli effetti del rumore nella ricostruzione è necessario introdurre un termine di regolarizzazione di Tikhonov. Si considera quindi il seguente problema di ottimizzazione.
\begin{align*}
  x^* = \arg\min_x \frac{1}{2} ||Ax - b||_2^2 + \frac{\lambda}{2} ||x||_2^2
\end{align*}

La funzione $f$ da minimizzare diventa
$f(x) = \frac{1}{2} ||Ax - b||_2^2 + \frac{\lambda}{2} ||x||_2^2$
il cui gradiente $\nabla f$ è dato da
$\nabla f(x) = A^TAx - A^Tb + λx$.

Utilizzando il metodo del gradiente coniugato implementato dalla funzione `minimize` ed il metodo del gradiente implementato a lezione, calcolare la soluzione del precendente problema di minimo regolarizzato per differenti valori di $\lambda$. 
"""



"""## 4) Variazione Totale (Facoltativo) 

Un altra funzione adatta come termine di regolarizzazione è la Variazione Totale. Data $u$ immagine di dimensioni $m\times n$ la variazione totale $TV$ di $u$ è definit come:
\begin{align*}
  TV(u) = \sum_i^n{\sum_j^m{\sqrt{||\nabla u(i, j)||_2^2 + \epsilon^2}}}
\end{align*}
Per calcolare il gradiente dell'immagine $\nabla u$ usiamo la funzione `np.gradient` che approssima la derivata per ogni pixel calcolando la differenza tra pixel adiacenti. I risultati sono due immagini della stessa dimensione dell'immagine in input, una che rappresenta il valore della derivata orizzontale `dx` e l'altra della derivata verticale `dy`. Il gradiente dell'immagine nel punto $(i, j)$ è quindi un vettore di due componenti, uno orizzontale contenuto in `dx` e uno verticale in `dy`.

Come nei casi precedenti il problema di minimo che si va a risolvere è il seguente:
\begin{align*}
  x^* = \arg\min_x \frac{1}{2} ||Ax - b||_2^2 + \lambda TV(u)
\end{align*}
il cui gradiente $\nabla f$ è dato da
\begin{align*}
\nabla f(x) = (A^TAx - A^Tb)  + \lambda \nabla TV(x)
\end{align*}

Utilizzando il metodo del gradiente implementato a lezione, calcolare la soluzione del precendente problema di minimo regolarizzato per differenti valori di $\lambda$. 


---
Per risolvere il problema di minimo è necessario anche calcolare il gradiente della variazione totale che è definito nel modo seguente
\begin{align*}
  \nabla TV(u) = -div\left(\frac{\nabla u}{\sqrt{||\nabla u||_2^2 + \epsilon^2}}\right)
\end{align*}

\begin{align*}
  div(F) = \frac{\partial F_x}{\partial x} + \frac{\partial F_y}{\partial y}
\end{align*}

$div(F)$ è la divergenza del campo vettoriale $F$, nel nostro caso $F$ ha due componenti dati dal gradiente dell'immagine $\nabla u$ scalato per il valore $ \frac{1}{\sqrt{||\nabla u||_2^2 + \epsilon^2}}$. Per calcolare la divergenza bisogna calcolare la derivata orizzontale $\frac{\partial F_x}{\partial x}$ della componente $x$ di $F$ e sommarla alla derivata verticale $\frac{\partial F_y}{\partial y}$ della componente $y$ di $F$. Per specificare in quale direzione calcolare la derivata con la funzione `np.gradient` utilizziamo il parametro `axis = 0` per l'orizzontale e `axis = 1` per la verticale.
"""

eps = 1e-2

# Variazione totale
def totvar(x):
  # Calcola il gradiente di x
  dx, dy = np.gradient(x)
  n2 = np.square(dx) + np.square(dy)

  # Calcola la variazione totale di x
  tv = np.sqrt(n2 + eps**2).sum()
  return tv

# Gradiente della variazione totale
def grad_totvar(x):
  # Calcola il numeratore della frazione
  dx, dy = np.gradient(x)

  # Calcola il denominatore della frazione
  n2 = np.square(dx) + np.square(dy)
  den = np.sqrt(n2 + eps**2)

  # Calcola le due componenti di F dividendo il gradiente per il denominatore
  Fx = dx / den
  Fy = dy / den

  # Calcola la derivata orizzontale di Fx 
  dFdx = np.gradient(Fx, axis=0)
  
  # Calcola la derivata verticale di Fy
  dFdy = np.gradient(Fy, axis=1)

  # Calcola la divergenza 
  div = (dFdx + dFdy)

  # Restituisci il valore del gradiente della variazione totale
  return -div



"""# Relazione

1.   Riportare e commentare i risultati ottenuti nei punti 2. 3. (e 4.) su un immagine del set creato e su altre due immagini in bianco e nero  (fotografiche/mediche/astronomiche)
2.   Riportare delle tabelle con le misure di PSNR e MSE ottenute al variare dei parametri (dimensione kernel, valore di sigma, la deviazione standard del rumore, il parametro di regolarizzazione). 
3. Calcolare sull’intero set di immagini medie e deviazione standard delle metriche per alcuni valori fissati dei parametri.  
4. Analizzare su 2 esecuzioni le proprietà dei metodi numerici utilizzati (gradiente coniugato e gradiente) in termini di numero di iterazioni, andamento dell’errore, della funzione obiettivo, norma del gradiente. 


"""